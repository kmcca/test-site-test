"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[85850],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>g});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),d=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},l=function(e){var n=d(e.components);return a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=d(t),g=r,f=p["".concat(c,".").concat(g)]||p[g]||u[g]||i;return t?a.createElement(f,o(o({ref:n},l),{},{components:t})):a.createElement(f,o({ref:n},l))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=p;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var d=2;d<i;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},84522:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=t(87462),r=(t(67294),t(3905));const i={title:"Understanding Agent-Based Scanning Evidence Collection",slug:"/r/c_sc_evidence"},o=void 0,s={unversionedId:"guides/sca/using_agent_based_scans/understanding_agent_evidence",id:"guides/sca/using_agent_based_scans/understanding_agent_evidence",title:"Understanding Agent-Based Scanning Evidence Collection",description:"Because the scanning process consists of building the code to be scanned, generating a dependency graph from the built code, and identifying libraries used with the dependency graph, Veracode Software Composition Analysis agent-based scanning requires the source code of the repository you want to scan in order to function properly. Libraries are identified by sending information to Veracode to match against the Veracode database. This section provides details on what information is sent from your environment to Veracode.",source:"@site/docs/guides/07_sca/04_using_agent_based_scans/02_understanding_agent_evidence.md",sourceDirName:"guides/07_sca/04_using_agent_based_scans",slug:"/r/c_sc_evidence",permalink:"/km-docusaurus-test/r/c_sc_evidence",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Understanding Agent-Based Scanning Evidence Collection",slug:"/r/c_sc_evidence"},sidebar:"tutorialSidebar",previous:{title:"Understanding Deployment Options for Agent-Based Scanning",permalink:"/km-docusaurus-test/r/Understanding_Deployment_Options_for_Agent_Based_Scanning"},next:{title:"About the Veracode Vulnerability Database",permalink:"/km-docusaurus-test/r/About_the_Veracode_Vulnerability_Database"}},c={},d=[{value:"What Veracode Does Not Send",id:"what-veracode-does-not-send",level:3},{value:"Git Information",id:"git-information",level:3},{value:"Language Type",id:"language-type",level:3},{value:"Library Identification",id:"library-identification",level:3}],l={toc:d};function u(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Because the scanning process consists of building the code to be scanned, generating a dependency graph from the built code, and identifying libraries used with the dependency graph, Veracode Software Composition Analysis agent-based scanning requires the source code of the repository you want to scan in order to function properly. Libraries are identified by sending information to Veracode to match against the Veracode database. This section provides details on what information is sent from your environment to Veracode."),(0,r.kt)("h3",{id:"what-veracode-does-not-send"},"What Veracode Does Not Send"),(0,r.kt)("p",null,"Veracode never sends your source code off of your environment. Veracode also never sends call chains built for vulnerable method calculation from your environment, but instead matches them on your environment."),(0,r.kt)("h3",{id:"git-information"},"Git Information"),(0,r.kt)("p",null,"Veracode SCA requires that any repository being scanned contains Git metadata in a ",(0,r.kt)("inlineCode",{parentName:"p"},".git")," folder because agent-based scanning uses this information to identify the repository, and track commit, branch, and tag information. The Git metadata is sent to Veracode to evaluate and identify this information."),(0,r.kt)("h3",{id:"language-type"},"Language Type"),(0,r.kt)("p",null,"Before beginning a scan, agent-based scans identify the build and package managers used in your repository. Veracode SCA finds the configuration files for a given build or package manager in the root of the project, or in a location where a configuration file might be typically found. For example, a ",(0,r.kt)("inlineCode",{parentName:"p"},"pom.xml")," in the root of a project indicates a Maven repository. This information is sent to the Veracode to distinguish coordinates among the various build and package managers."),(0,r.kt)("h3",{id:"library-identification"},"Library Identification"),(0,r.kt)("p",null,"To identify the open-source libraries that your code uses, Veracode SCA uses a set of coordinates from the dependency graph generated during the build process in combination with the language type. The coordinates for each language are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Maven/Gradle/Scala: groupId, artifactId, version"),(0,r.kt)("li",{parentName:"ul"},"NPM/Bower/Yarn: library name, version"),(0,r.kt)("li",{parentName:"ul"},"Ruby Gems: library name, version"),(0,r.kt)("li",{parentName:"ul"},"Python: library name, version"),(0,r.kt)("li",{parentName:"ul"},"PHP: library name, version"),(0,r.kt)("li",{parentName:"ul"},"Go: library name, commit hash/version"),(0,r.kt)("li",{parentName:"ul"},".NET: library name, version"),(0,r.kt)("li",{parentName:"ul"},"Objective-C: library name, version")),(0,r.kt)("p",null,"By sending these coordinates along with the language type, Veracode SCA is able to uniquely identify the libraries used in your project."))}u.isMDXComponent=!0}}]);